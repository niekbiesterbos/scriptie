[
  {
    "day": 1,
    "strategy": "None",
    "part1": "myfile = open('input.txt', 'r')\ncontents = myfile.read().strip().split()\nmyfile.close()\n\ndef solve():\n    ans = 0\n    old = set([ans])\n\n    found = False\n    iter = 0\n    while not found:\n\n        for i in contents:\n            if i[0] == '-':\n                ans -= int(i[1:])\n            elif i[0] == '+':\n                ans += int(i[1:])\n\n            if ans in old:\n                print(\"Part Two:\", ans)\n                found = True\n                break\n\n            old.add(ans)\n\n        if iter == 0:\n            print(\"Part One:\", ans)\n\n        iter += 1\n\nsolve()"
  },
  {
    "day": 2,
    "strategy": "None",
    "part1": "def day2b(puzzle_input: str) -> str:\n    patterns = set()\n    for line in puzzle_input.strip().split('\\n'):\n        for i in range(len(line)):\n            pattern = line[:i] + '.' + line[i+1:]\n            if pattern in patterns:\n                return pattern.replace('.', '')\n            patterns.add(pattern)"
  },
  {
    "day": 3,
    "strategy": "None",
    "part1": "import numpy as np\n\nSIZE = 1000\n\ndef parse_claim(s):\n    identifier, _, dist, size = s.split(' ')\n    fromleft, fromtop = map(int, dist[:-1].split(','))\n    width, height = map(int, size.split('x'))\n    return identifier, fromleft, fromtop, width, height\n\ndef p1(d):\n    rect = np.zeros((SIZE, SIZE))\n    for claim in d:\n         iden, leftoff, topoff, w, h = parse_claim(claim)\n         rect[leftoff:leftoff + w, topoff:topoff+h] += 1\n    return np.size(np.where(rect >= 2)[0])\n\ndef p2(d):\n    rect = np.zeros((SIZE, SIZE))\n    for claim in d:\n        iden, leftoff, topoff, w, h = parse_claim(claim)\n        rect[leftoff:leftoff + w, topoff:topoff+h] += 1\n    for claim in d:\n        iden, leftoff, topoff, w, h = parse_claim(claim)\n        if np.all(rect[leftoff:leftoff + w, topoff:topoff+h] == 1):\n            return iden"
  },
  {
    "day": 4,
    "strategy": "GreedyAlgorithm",
    "part1": "from utils.decorators import time_it\nfrom collections import defaultdict, Counter\n\nwith open('input') as f:\n    puzzle_input = f.readlines()\n\n\n@time_it\ndef part1(n):\n    guards = defaultdict(list)\n    times = defaultdict(int)\n    for line in sorted(n):\n        time, event = line.split('] ')\n        minute = int(time[-2:])\n\n        if 'Guard' in event:\n            id = int(event.split('#')[1].split(' ')[0])\n        elif 'falls' in event:\n            start = minute\n        elif 'wakes' in event:\n            end = minute\n            for x in range(start, end):\n                guards[id].append(x)\n            times[id] += end - start\n\n    guard, time = max(times.items(), key=lambda i: i[1])\n    minute, count = Counter(guards[guard]).most_common(1)[0]\n\n    count_max = -1\n    guard2 = -1\n    for g in guards:\n        minute2, count = Counter(guards[g]).most_common(1)[0]\n        if count > count_max:\n            count_max = count\n            minute_max = minute2\n            guard2 = g\n\n    return guard * minute, guard2 * minute_max\n\n\n@time_it\ndef part2(guards, times):\n    pass\n\n\ntest_one = [\n    '[1518-11-01 00:00] Guard #10 begins shift',\n    '[1518-11-01 00:05] falls asleep',\n    '[1518-11-01 00:25] wakes up',\n    '[1518-11-01 00:30] falls asleep',\n    '[1518-11-01 00:55] wakes up',\n    '[1518-11-01 23:58] Guard #99 begins shift',\n    '[1518-11-02 00:40] falls asleep',\n    '[1518-11-02 00:50] wakes up',\n    '[1518-11-03 00:05] Guard #10 begins shift',\n    '[1518-11-03 00:24] falls asleep',\n    '[1518-11-03 00:29] wakes up',\n    '[1518-11-04 00:02] Guard #99 begins shift',\n    '[1518-11-04 00:36] falls asleep',\n    '[1518-11-04 00:46] wakes up',\n    '[1518-11-05 00:03] Guard #99 begins shift',\n    '[1518-11-05 00:45] falls asleep',\n    '[1518-11-05 00:55] wakes up'\n]\np1, p2 = part1(test_one)\nassert p1 == 240\nassert p2 == 4455\n\nprint(f'Part 1, 2: {part1(puzzle_input)}')"
  },
  {
    "day": 5,
    "strategy": "None",
    "part1": "import sys\n\nline = [line for line in sys.stdin][0].strip()\n\n\ndef are_opp(a, b):\n    return (a.lower() == b.lower() and\n            ((a.isupper() and b.islower()) or\n             (a.islower() and b.isupper())))\n\n\ndef react(line):\n    buf = []\n    for c in line:\n        if buf and are_opp(c, buf[-1]):\n            buf.pop()\n        else:\n            buf.append(c)\n    return len(buf)\n\n\nagents = set([c.lower() for c in line])\n\n# part 1\nprint(react(line))\n\n# part 2\nprint(min([react(line.replace(a, '').replace(a.upper(), ''))\n           for a in agents]))"
  },
  {
    "day": 6,
    "strategy": "GreedyAlgorithm",
    "part1": "import os\nfrom collections import defaultdict\n\ndef part1(lines):\n    coords = set()\n    max_r = max_c = 0\n\n    for line in lines:\n        r, c = map(int, line.split(\", \"))\n        coords.add((r, c))\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n\n    coord_id_to_point = {coord_id: point for coord_id, point in enumerate(coords, start=1)}\n    region_sizes = defaultdict(int)\n    infinite_ids = set()\n\n    for i in range(max_r + 1):\n        for j in range(max_c + 1):\n            min_dists = sorted([(abs(r - i) + abs(c - j), coord_id) for coord_id, (r, c) in coord_id_to_point.items()])\n\n            if len(min_dists) == 1 or min_dists[0][0] != min_dists[1][0]:\n                coord_id = min_dists[0][1]\n                region_sizes[coord_id] += 1\n\n                if i == 0 or i == max_r or j == 0 or j == max_c:\n                    infinite_ids.add(coord_id)\n\n    return max(size for coord_id, size in region_sizes.items() if coord_id not in infinite_ids)\n\n\ndef part2(lines, manhattan_limit=10000):\n    coords = set()\n    max_r = max_c = 0\n\n    for line in lines:\n        r, c = map(int, line.split(\", \"))\n        coords.add((r, c))\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n\n    size_shared_region = 0\n\n    for i in range(max_r + 1):\n        for j in range(max_c + 1):\n            size_shared_region += int(sum(abs(r - i) + abs(c - j) for r, c in coords) < manhattan_limit)\n\n    return size_shared_region\n\nday = os.path.basename(__file__)[3:5]\nlines = [line.strip() for line in open(\"input_{}.txt\".format(day), \"r\").readlines()]\nprint(part1(lines))\nprint(part2(lines))"
  },
  {
    "day": 7,
    "strategy": "GraphTraversal",
    "part1": "import networkx as nx\n\ndef solve(lines):\n    G = nx.DiGraph()\n    for line in lines:\n        parts = line.split(\" \")\n        G.add_edge(parts[1], parts[7])\n    print(''.join(nx.lexicographical_topological_sort(G)))"
  },
  {
    "day": 8,
    "strategy": "Recursion",
    "part1": "data = [int(x) for x in INPUT.split()]\n\ndef parse(data):\n    children, metas = data[:2]\n    data = data[2:]\n    scores = []\n    totals = 0\n\n    for i in range(children):\n        total, score, data = parse(data)\n        totals += total\n        scores.append(score)\n\n    totals += sum(data[:metas])\n\n    if children == 0:\n        return (totals, sum(data[:metas]), data[metas:])\n    else:\n        return (\n            totals,\n            sum(scores[k - 1] for k in data[:metas] if k > 0 and k <= len(scores)),\n            data[metas:]\n        )\n\ntotal, value, remaining = parse(data)\n\nprint('part 1:', total)\nprint('part 2:', value)"
  },
  {
    "day": 9,
    "strategy": "GraphTraversal",
    "part1": "from collections import deque, defaultdict\n\ndef play_game(max_players, last_marble):\n    scores = defaultdict(int)\n    circle = deque([0])\n\n    for marble in range(1, last_marble + 1):\n        if marble % 23 == 0:\n            circle.rotate(7)\n            scores[marble % max_players] += marble + circle.pop()\n            circle.rotate(-1)\n        else:\n            circle.rotate(-1)\n            circle.append(marble)"
  },
  {
    "day": 10,
    "strategy": "None",
    "part1": "# particles is a list of (px, py, vx, vy) tuples\ndef get_starting_time(particles):\n    # find two particles travelling in opposite direction the fastest\n    (u1x, u1y, v1x, v1y) = min(particles, key=lambda p: (p[2], p[3]))\n    (u2x, u2y, v2x, v2y) = max(particles, key=lambda p: (p[2], p[3]))\n    # find the difference vector between these two particles\n    (udx, udy, vdx, vdy) = (u2x - u1x, u2y - u1y, v2x - v1x, v2y - v1y)\n    # return the time they are closest\n    return int((-vdx * udx - vdy * udy) / (vdx * vdx + vdy * vdy))"
  },
  {
    "day": 11,
    "strategy": "None",
    "part1": "import numpy\nserial = int(INPUT)\n\ndef power(x, y):\n    rack = (x + 1) + 10\n    power = rack * (y + 1)\n    power += serial\n    power *= rack\n    return (power // 100 % 10) - 5\n\ngrid = numpy.fromfunction(power, (300, 300))\n\nfor width in range(3, 300):\n    windows = sum(grid[x:x-width+1 or None, y:y-width+1 or None] for x in range(width) for y in range(width))\n    maximum = int(windows.max())\n    location = numpy.where(windows == maximum)\n    print(width, maximum, location[0][0] + 1, location[1][0] + 1)"
  },
  {
    "day": 12,
    "strategy": "None",
    "part1": "with open('input.txt') as f:\n   ls = [s.strip() for s in f.readlines()]\n\ninit_state = \"####....#...######.###.#...##....#.###.#.###.......###.##..##........##..#.#.#..##.##...####.#..##.#\"\n\nrules = {}\nimport parse\n\npr = parse.compile(\"{} => {}\")\n\nfor l in ls:\n   r = pr.parse(l)\n   rules[r[0]] = r[1]\n\ndef sum_plants(curr):\n   diff = (len(curr) - 100) // 2\n   sum = 0\n   for i, c in enumerate(curr):\n      if c == '#':\n         sum += (i - diff)\n   return sum\n\ncurr = init_state\nprev_sum = sum_plants(init_state)\ndiffs = []\nnum_iters = 1000\nfor i in range(num_iters):\n   if(i == 20):\n      print(\"Part 1: \" + str(sum_plants(curr)))\n   curr = \"....\" + curr + \"....\"\n   next = \"\"\n   for x in range(2, len(curr) - 2):\n      sub = curr[x-2:x+3]\n      next+= rules[sub]\n   curr = next\n   currsum = sum_plants(curr)\n   diff = currsum - prev_sum\n   diffs.append(diff)\n   if(len(diffs) > 100): diffs.pop(0)\n   prev_sum = currsum\n\nlast100diff = sum(diffs) // len(diffs)\n\ntotal = (50000000000 - num_iters) * last100diff + sum_plants(curr) \n\nprint(\"Part 2: \" + str(total))"
  },
  {
    "day": 13,
    "strategy": "None",
    "part1": "from collections import defaultdict\nfrom typing import List, Tuple, Dict\n\n\nclass Cart:\n    def __init__(self, pos: complex, di: complex):\n        self.position = pos\n        self.direction = di\n        self.cross_mod = 0\n        self.dead = False\n\n\ndef setup(input_file_lines: List[str]) -> Tuple[Dict[complex, str], List[Cart]]:\n    tracks = defaultdict(lambda: \"\")  # only stores important tracks: \\ / +\n    carts = []\n    for y, line in enumerate(input_file_lines):\n        for x, char in enumerate(line):\n            if char == \"\\n\":\n                continue\n            if char in \"<v>^\":\n                direction = {\n                    \"<\": -1,\n                    \"v\": +1j,\n                    \">\": +1,\n                    \"^\": -1j,\n                }[char]\n                carts.append(Cart(x + y * 1j, direction))  # location, direction, crossings\n                part = {\n                    \"<\": \"-\",\n                    \"v\": \"|\",\n                    \">\": \"-\",\n                    \"^\": \"|\",\n                }[char]\n            else:\n                part = char\n            if part in \"\\\\/+\":\n                tracks[(x + y * 1j)] = part\n    return tracks, carts\n\n\ndef turn_cart(cart: Cart, part: str):\n    \"\"\"This space uses a downwards-facing Y axis, which means all calculations\n    must flip their imaginary part. For example, rotation to the left\n    (counterclockwise) would be multiplying by -1j instead of by +1j.\"\"\"\n    if not part:  # empty track is impossible, and | or - don't matter\n        return\n    if part == \"\\\\\":\n        if cart.direction.real == 0:\n            cart.direction *= -1j  # ⮡ ⮢\n        else:\n            cart.direction *= +1j  # ⮧ ⮤\n    if part == \"/\":\n        if cart.direction.real == 0:\n            cart.direction *= +1j  # ⮣ ⮠\n        else:\n            cart.direction *= -1j  # ⮥ ⮦\n    if part == \"+\":\n        cart.direction *= -1j * 1j ** cart.cross_mod  # rotate left, forward, or right\n        cart.cross_mod = (cart.cross_mod + 1) % 3\n\n\ndef solve_a(input_file_lines: List[str]) -> str:\n    tracks, carts = setup(input_file_lines)\n    while True:\n        carts.sort(key=lambda c: (c.position.imag, c.position.real))\n        for ci, cart in enumerate(carts):\n            cart.position += cart.direction\n            if any(c2.position == cart.position for c2i, c2 in enumerate(carts) if c2i != ci):\n                return str(int(cart.position.real)) + \",\" + str(int(cart.position.imag))\n                # 14, 42\n            part = tracks[cart.position]\n            turn_cart(cart, part)\n\n\ndef solve_b(input_file_lines: List[str]) -> str:\n    tracks, carts = setup(input_file_lines)\n    while len(carts) > 1:\n        carts.sort(key=lambda c: (c.position.imag, c.position.real))\n        for ci, cart in enumerate(carts):\n            if cart.dead:\n                continue\n            cart.position += cart.direction\n            for ci2, cart2 in enumerate(carts):\n                if ci != ci2 and cart.position == cart2.position and not cart2.dead:\n                    cart.dead = True\n                    cart2.dead = True\n                    break\n            if cart.dead:\n                continue\n            part = tracks[cart.position]\n            turn_cart(cart, part)\n        carts = [c for c in carts if not c.dead]\n    if not carts:\n        return \"ERROR: there's an even number of carts, there's isn't 1 cart left at the end!\"\n    cart = carts[0]\n    return str(int(cart.position.real)) + \",\" + str(int(cart.position.imag))\n    # 8,7"
  },
  {
    "day": 14,
    "strategy": "DynamicProgramming",
    "part1": "def generateRecipe():\n  state = [3, 7]\n  pos = [0, 1]\n  for x in state:\n    yield x\n  for t in range(10000000000):\n    score = [int(c) for c in str(state[pos[0]] + state[pos[1]])]\n    state.extend(score)\n    for i in range(2):\n      pos[i] = (pos[i] + 1 + state[pos[i]]) % len(state)\n    for x in score:\n      yield x"
  },
  {
    "day": 15,
    "strategy": "GraphTraversal",
    "part1": "import sys\nfrom collections import deque\nfrom dataclasses import dataclass\n\ngob_attack = 3\ntry:    elf_attack = int(sys.argv[1])\nexcept: elf_attack = gob_attack\n\n@dataclass(order=True)\nclass Unit:\n    y : int\n    x : int\n    hp : int\n    typ : str\n    @property\n    def attack(self):\n        return elf_attack if self.typ == 'E' else gob_attack\n    def dist(a,b):\n        return abs(a.x-b.x) + abs(a.y-b.y)\n    def __str__(self):\n        return f'[{self.typ}: {self.hp}]'\n\nG = []\nE = []\nM = []\nfor i,line in enumerate(sys.stdin):\n    line = line.strip()\n    for j,c in enumerate(line):\n        if c == 'G':\n            G.append(Unit(i,j,200,'G'))\n        if c == 'E':\n            E.append(Unit(i,j,200,'E'))\n    M.append([int(c == '#') for c in line])\n\nelfded = False\n\ndef viz():\n    H = len(M)\n    W = len(M[0])\n    Mc = [m[:] for m in M]\n\n    units = sorted(G + E)\n\n    for e in units:\n        if e.typ == 'E': Mc[e.y][e.x] = 3\n        else:            Mc[e.y][e.x] = 2\n\n    by_row = [[] for _ in range(H)]\n    for f in sorted(G + E):\n        by_row[f.y].append(f'[{f.typ}: {f.hp}]')\n\n    for i in range(H):\n        s = ''.join('.#GE'[Mc[i][j]] for j in range(W))\n        print(s, ' '.join(by_row[i]))\n    print()\n\ndef neigh(x,y):\n    return [(x,y-1),(x-1,y),(x+1,y),(x,y+1)]\n\nturns = 0\nwhile E and G:\n    units = sorted(G+E)\n\n    for unit in units:\n        if unit.typ == 'X': continue\n\n        enemies = sorted(e for e in units if e.typ != unit.typ)\n        targets = set().union(*(set(neigh(e.x,e.y)) for e in enemies if e.typ != 'X'))\n\n        cands = []\n        goald = 1e9\n        blocked = {(e.x,e.y) for e in units if e.typ != 'X'}\n        Q = deque([(unit.x,unit.y,0,None)])\n        while Q:\n            x,y,d,step1 = Q.popleft()\n            if d > goald: break\n            if M[y][x] or ((x,y) in blocked and d > 0): continue\n            blocked.add((x,y))\n\n            if d == 1:\n                step1 = (x,y)\n            if (x,y) in targets:\n                goald = d\n                cands.append([y,x,d,step1])\n            for s,t in neigh(x,y):\n                Q.append((s,t,d+1,step1))\n\n        if len(cands) == 0: continue\n\n        x,y,d,step1 = min(cands)\n        if d > 0:\n            unit.x,unit.y = step1\n        if d <= 1:\n            target = min((e for e in enemies if e.typ != 'X' and e.dist(unit) == 1),\n                         key=lambda x: x.hp)\n            target.hp -= unit.attack\n            if target.hp <= 0:\n                if target.typ == 'E':\n                    elfded = True\n                target.typ = 'X'\n\n    # Purge the dead\n    E = [e for e in E if e.typ != 'X']\n    G = [e for e in G if e.typ != 'X']\n\n    turns += 1\n    print(f'=== round {turns} ===')\n    viz()\n\nhp = sum(e.hp for e in G) + sum(e.hp for e in E)\nprint(f'Result: {(turns-1)*hp}')\nprint(f'Did an elf die? {\"YNeos\"[1-elfded::2]}')"
  },
  {
    "day": 16,
    "strategy": "None",
    "part1": "#!/usr/bin/env python3\n\ndef list_map(f, s):\n    return list(map(f, s))\n\ndef addr(registers, a, b, c):\n    result = registers[::]\n    result[c] = result[a] + result[b]\n    return result\n\ndef addi(registers, a, b, c):\n    result = registers[::]\n    result[c] = result[a] + b\n    return result\n\ndef mulr(registers, a, b, c):\n    result = registers[::]\n    result[c] = result[a] * result[b]\n    return result\n\ndef muli(registers, a, b, c):\n    result = registers[::]\n    result[c] = result[a] * b\n    return result\n\ndef banr(registers, a, b, c):\n    result = registers[::]\n    result[c] = result[a] & result[b]\n    return result\n\ndef bani(registers, a, b, c):\n    result = registers[::]\n    result[c] = result[a] & b\n    return result\n\ndef borr(registers, a, b, c):\n    result = registers[::]\n    result[c] = result[a] | result[b]\n    return result\n\ndef bori(registers, a, b, c):\n    result = registers[::]\n    result[c] = result[a] | b\n    return result\n\ndef setr(registers, a, b, c):\n    result = registers[::]\n    result[c] = result[a]\n    return result\n\ndef seti(registers, a, b, c):\n    result = registers[::]\n    result[c] = a\n    return result\n\ndef gtir(registers, a, b, c):\n    result = registers[::]\n    result[c] = bool(a > result[b])\n    return result\n\ndef gtri(registers, a, b, c):\n    result = registers[::]\n    result[c] = bool(result[a] > b)\n    return result\n\ndef gtrr(registers, a, b, c):\n    result = registers[::]\n    result[c] = bool(result[a] > result[b])\n    return result\n\ndef eqir(registers, a, b, c):\n    result = registers[::]\n    result[c] = bool(a == result[b])\n    return result\n\ndef eqri(registers, a, b, c):\n    result = registers[::]\n    result[c] = bool(result[a] == b)\n    return result\n\ndef eqrr(registers, a, b, c):\n    result = registers[::]\n    result[c] = bool(result[a] == result[b])\n    return result\n\nOPERATIONS = [\n    addr, addi,\n    mulr, muli,\n    banr, bani,\n    borr, bori,\n    setr, seti,\n    gtir, gtri, gtrr,\n    eqir, eqri, eqrr\n]\n\ndef possible_operations(instruction, before, after):\n    result = set()\n    for operation in OPERATIONS:\n        op_result = operation(before, *instruction[1:])\n        if op_result == after:\n            result.add(operation)\n    return result\n\ndef problem1(LINES):\n    i = 0\n    experiments = []\n    while LINES[i].strip():\n        before, instruction, after = LINES[i:i+3]\n        i += 4\n        experiments.append((\n            list_map(int, instruction.split(' ')),\n            eval(before[8:]),\n            eval(after[8:])\n        ))\n    return len([experiment for experiment in experiments if len(possible_operations(*experiment)) >= 3])\n\ndef problem2(LINES):\n    i = 0\n    experiments = []\n    while LINES[i].strip():\n        before, instruction, after = LINES[i:i+3]\n        i += 4\n        experiments.append((\n            list_map(int, instruction.split(' ')),\n            eval(before[8:]),\n            eval(after[8:])\n        ))\n\n    operations = {opcode : set(OPERATIONS) for opcode in range(16)}\n    for experiment in experiments:\n        opcode = experiment[0][0]\n        operations[opcode].intersection_update(possible_operations(*experiment))\n\n    while True:\n        unique_ops = {}\n        for op, ops in operations.items():\n            if len(ops) == 1:\n                unique_ops[op] = ops\n        for op_, ops_ in unique_ops.items():\n            for op, ops in operations.items():\n                if op != op_:\n                    ops.difference_update(ops_)\n        if len(unique_ops) == len(operations):\n            break\n\n    for op in operations:\n        operations[op] = operations[op].pop()\n    registers = [0, 0, 0, 0]\n    for line in LINES[i:]:\n        if not line.strip():\n            continue\n        opcode, a, b, c = list_map(int, line.split(' '))\n        registers = operations[opcode](registers, a, b, c)\n    return registers[0]\n\ndef parse_input_file(fname):\n    s = open(fname).read()\n    if s and s[-1] == '\\n':\n        s = s[:-1]\n    return s.splitlines()\n\ndef main():\n    l = parse_input_file('input.txt')\n    print(problem1(l))\n    print(problem2(l))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "day": 17,
    "strategy": "Recursion",
    "part1": "import collections\n\nclay = collections.defaultdict(bool)\n\nfor line in open('inputs/day17').read().splitlines():\n    a, brange = line.split(',')\n    if a[0] == 'x':\n        x = int(a.split('=')[1])\n        y1, y2 = map(int, brange.split('=')[1].split('..'))\n\n        for y in range(y1, y2 + 1):\n            clay[(x, y)] = True\n    else:\n        y = int(a.split('=')[1])\n        x1, x2 = map(int, brange.split('=')[1].split('..'))\n\n        for x in range(x1, x2 + 1):\n            clay[(x, y)] = True\n\nymin, ymax = min(clay, key=lambda p: p[1])[1], max(clay, key=lambda p: p[1])[1]\n\nsettled = set()\nflowing = set()\n\ndef fill(pt, direction=(0, 1)):\n    flowing.add(pt)\n\n    below = (pt[0], pt[1] + 1)\n\n    if not clay[below] and below not in flowing and 1 <= below[1] <= ymax:\n        fill(below)\n\n    if not clay[below] and below not in settled:\n        return False\n\n    left = (pt[0] - 1, pt[1])\n    right = (pt[0] + 1, pt[1])\n\n    left_filled = clay[left] or left not in flowing and fill(left, direction=(-1, 0))\n    right_filled = clay[right] or right not in flowing and fill(right, direction=(1, 0))\n\n    if direction == (0, 1) and left_filled and right_filled:\n        settled.add(pt)\n\n        while left in flowing:\n            settled.add(left)\n            left = (left[0] - 1, left[1])\n\n        while right in flowing:\n            settled.add(right)\n            right = (right[0] + 1, right[1])\n\n    return direction == (-1, 0) and (left_filled or clay[left]) or \\\n        direction == (1, 0) and (right_filled or clay[right])\n\nfill((500, 0))\n\nprint('part 1:', len([pt for pt in flowing | settled if ymin <= pt[1] <= ymax]))\nprint('part 2:', len([pt for pt in settled if ymin <= pt[1] <= ymax]))"
  },
  {
    "day": 18,
    "strategy": "None",
    "part1": "import re\nimport copy\n\ndata = open('aoc18.in.txt').read()\n\nground = [list(ln.strip()) for ln in data.splitlines()]\n\ndef get(y, x):\n    if y < 0 or x < 0:\n        return ' '\n    try:\n        return ground[y][x]\n    except IndexError:\n        return ' '\n\nsnapshots = []\nfor g in range(1, 1000):\n    ground2 = copy.deepcopy(ground)\n    for (y, row) in enumerate(ground):\n        for (x, val) in enumerate(row):\n            neighbors = ''.join(get(y+a, x+b) for (a, b) in\n                                [(-1, -1), (-1, 0), (-1, 1), (0, -1),\n                                 (0, 1), (1, -1), (1, 0), (1, 1)])\n            if val == '.':\n                if re.search('[|].*[|].*[|]', neighbors):\n                    ground2[y][x] = '|'\n            elif val == '|':\n                if re.search('[#].*[#].*[#]', neighbors):\n                    ground2[y][x] = '#'\n            elif val == '#':\n                if not re.search('[#].*[|]|[|].*[#]', neighbors):\n                    ground2[y][x] = '.'\n    ground = ground2\n\n    snapshot = '\\n'.join(''.join(row) for row in ground)\n    if snapshot in snapshots:\n        i = snapshots.index(snapshot)\n        print(\"Found %d as a repeat of %d\" % (g, 1+i))\n        period = g - (1+i)\n        while (i+1) % period != 1000000000 % period:\n            i += 1\n        # print(snapshots[i])\n        count1 = len(re.findall('[|]', snapshots[i]))\n        count2 = len(re.findall('[#]', snapshots[i]))\n        print((i+1, count1, count2))\n        print(count1 * count2)\n        break\n    snapshots.append(snapshot)\n\n    if g == 10:\n        count1 = len(re.findall('[|]', snapshot))\n        count2 = len(re.findall('[#]', snapshot))\n        print((g, count1, count2))\n        print(count1 * count2)"
  },
  {
    "day": 19,
    "strategy": "None",
    "part1": "class Example:\n    def __init__(self):\n        self.before = None\n        self.after = None\n        self.instruction = None\n\nclass Machine:\n    def __init__(self):\n        self.regs = [0, 0, 0, 0, 0, 0]\n        self.instr_ptr = 0\n        self.instr_val = 0\n        self.ops = { \"gtri\" : self.ex_gtri, \"bani\" : self.ex_bani, \"eqrr\" : self.ex_eqrr, \n                          \"gtir\" : self.ex_gtir, \"eqir\" : self.ex_eqir, \"bori\" : self.ex_bori, \n                          \"seti\" : self.ex_seti, \"setr\" : self.ex_setr,\n                          \"addr\" : self.ex_addr, \"borr\" : self.ex_borr, \"muli\" : self.ex_muli, \n                          \"banr\" : self.ex_banr, \"addi\" : self.ex_addi, \"eqri\" : self.ex_eqri, \n                          \"mulr\" : self.ex_mulr, \"gtrr\" : self.ex_gtrr}\n    \ndef ex_addr(self, a, b, r):\n    self.regs[r] = self.regs[a] + self.regs[b]\n    \ndef ex_addi(self, a, b, r):\n    self.regs[r] = self.regs[a] + b\n    \ndef ex_mulr(self, a, b, r):\n    self.regs[r] = self.regs[a] * self.regs[b]\n    \ndef ex_muli(self, a, b, r):\n    self.regs[r] = self.regs[a] * b\n\ndef ex_banr(self, a, b, r):\n    self.regs[r] = self.regs[a] & self.regs[b]\n\ndef ex_bani(self, a, b, r):\n    self.regs[r] = self.regs[a] & b\n\ndef ex_borr(self, a, b, r):\n    self.regs[r] = self.regs[a] | self.regs[b]\n\ndef ex_bori(self, a, b, r):\n    self.regs[r] = self.regs[a] | b\n\ndef ex_setr(self, a, b, r):\n    self.regs[r] = self.regs[a]\n\ndef ex_seti(self, a, b, r):\n    self.regs[r] = a\n    \ndef ex_gtir(self, a, b, r):\n    self.regs[r] = 1 if a > self.regs[b] else 0\n\ndef ex_gtri(self, a, b, r):\n    self.regs[r] = 1 if self.regs[a] > b else 0\n\ndef ex_gtrr(self, a, b, r):\n    self.regs[r] = 1 if self.regs[a] > self.regs[b] else 0\n\ndef ex_eqir(self, a, b, r):\n    self.regs[r] = 1 if a == self.regs[b] else 0\n\ndef ex_eqri(self, a, b, r):\n    self.regs[r] = 1 if self.regs[a] == b else 0\n\ndef ex_eqrr(self, a, b, r):\n    self.regs[r] = 1 if self.regs[a] == self.regs[b] else 0\n\ndef ex_instr(self, instr):\n    op, a, b, r = instr\n    if op not in self.ops:\n        raise Exception(f\"Opcode {op} not defined!\")\n\n    print(instr, m.instr_val, m.regs,)\n    m.regs[m.instr_ptr] = m.instr_val\n    self.ops[op](a, b, r)\n    m.instr_val = m.regs[m.instr_ptr]\n    m.instr_val += 1\n    print(\"                   \",m.regs)\n    \ndef execute_program(self, program):\n    while m.instr_val < len(program):\n        self.ex_instr(program[m.instr_val])\n                \nm = Machine()\nprogram = []\nwith open(\"program2.txt\") as file:\n    for line in file.readlines():\n        if line[0:3] == \"#ip\":\n            m.instr_ptr = int(line[line.find(\" \"):])\n            m.instr_val = 0\n        else:\n            pieces = line.strip().split(\" \")\n            instr = [pieces[0]]\n            instr.extend([int(c) for c in pieces[1:]])\n            program.append(instr)\n\nm.execute_program(program)\n\nprint(m.regs)"
  },
  {
    "day": 20,
    "strategy": "Recursion",
    "part1": "from collections import defaultdict\nimport operator\ninp = \"...\"\nto_python = inp.replace(\"^\", \"['\").replace(\"$\",\"']\").replace(\"(\",\"',[['\") \\\n    .replace(\")\",\"']],'\").replace(\"|\",\"'],['\").replace(\"[\",\"(\").replace(\"]\",\")\")\nevaled_inp = eval(to_python)\n\nadj = defaultdict(set)\nmemo = dict()\n\nto_d = dict(zip(\"NESW\", [(-1, 0), (0, 1), (1, 0), (0, -1)]))\n\ndef connect(a, b):\n    nonlocal adj\n    adj[a].add(b)\n    adj[b].add(a)\n\ndef make_adj(cur_position, obj):\n    memo_key = (cur_position, obj)\n    if memo_key in memo:\n        return memo[memo_key]\n    \n    positions = set([cur_position])\n\n    for part in obj:\n        if isinstance(part, str):\n            for c in part:\n                new_positions = set()\n                for pos in positions:\n                    new_pos = tuple(map(operator.add, pos, to_d[c]))\n                    connect(pos, new_pos)\n                    new_positions.add(new_pos)\n                positions = new_positions\n        else:\n            positions = set(\n                thing\n                for pos in positions\n                for option in part\n                for thing in make_adj(pos, option)\n            )\n\n    memo[memo_key] = positions\n    return positions\n\nmake_adj((0, 0), evaled_inp)\n\ntodo = [(0, 0)]\nto_dist = dict()\ndist = 0\nwhile todo:\n    new_todo = []\n    for i in todo:\n        if i in to_dist:\n            continue\n        to_dist[i] = dist\n        new_todo.extend(adj[i])\n    todo = new_todo\n    dist += 1\n\nprint(max(to_dist.values()))\nprint(sum(i >= 1000 for i in to_dist.values()))"
  },
  {
    "day": 21,
    "strategy": "None",
    "part1": "def run_activation_system(magic_number, is_part_1):\n    seen = set()\n    c = 0\n    last_unique_c = -1\n\n    while True:\n        a = c | 65536\n        c = magic_number\n\n        while True:\n            c = (((c + (a & 255)) & 16777215) * 65899) & 16777215\n\n            if 256 > a:\n                if is_part_1:\n                    return c\n                else:\n                    if c not in seen:\n                        seen.add(c)\n                        last_unique_c = c\n                        break\n                    else:\n                        return last_unique_c\n            else:\n                a //= 256\n\n\nmagic_number = int(open(\"day21.txt\", \"r\").readlines()[8].split()[1])\nprint(run_activation_system(magic_number, True))\nprint(run_activation_system(magic_number, False))"
  },
  {
    "day": 22,
    "strategy": "GraphTraversal",
    "part1": "import networkx as nx\n\nrocky, wet, narrow = 0, 1, 2\ntorch, gear, neither = 0, 1, 2\nvalid_items = {rocky: (torch, gear), wet: (gear, neither), neither: (torch, neither)}\nvalid_regions = {torch: (rocky, narrow), gear: (rocky, wet), neither: (wet, narrow)}\n\n\ndef get_cave(file):\n    with open(file) as f:\n        lines = iter([line.strip() for line in f.read().strip().splitlines()])\n        depth = int(next(lines)[len(\"depth: \"):])\n        target = tuple([int(n) for n in next(lines)[len(\"target: \"):].split(\",\")])\n    return depth, target\n\n\ndef generate_grid(depth, corner):\n    # (x, y) -> geologic index, erosion level, risk\n    grid = {}\n\n    for y in range(0, corner[1] + 1):\n        for x in range(0, corner[0] + 1):\n            if (x, y) in [(0, 0), target]:\n                geo = 0\n            elif x == 0:\n                geo = y * 48271\n            elif y == 0:\n                geo = x * 16807\n            else:\n                geo = grid[(x-1, y)][1] * grid[(x, y-1)][1]\n            ero = (geo + depth) % 20183\n            risk = ero % 3\n            grid[(x, y)] = (geo, ero, risk)\n\n    return grid\n\n\ndef dijkstra(grid, corner, target):\n    graph = nx.Graph()\n    for y in range(0, corner[1] + 1):\n        for x in range(0, corner[0] + 1):\n            items = valid_items[grid[(x, y)]]\n            graph.add_edge((x, y, items[0]), (x, y, items[1]), weight=7)\n            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                new_x, new_y = x+dx, y+dy\n                if 0 <= new_x <= corner[0] and 0 <= new_y <= corner[1]:\n                    new_items = valid_items[grid[(new_x, new_y)]]\n                    for item in set(items).intersection(set(new_items)):\n                        graph.add_edge((x, y, item), (new_x, new_y, item), weight=1)\n\n    return nx.dijkstra_path_length(graph, (0, 0, torch), (target[0], target[1], torch))\n\n\ndepth, target = get_cave(\"./input.txt\")\ngrid = generate_grid(depth, target)\nprint(\"Answer 1:\", sum([v[2] for v in grid.values()]))\n\ncorner = (target[0] + 100, target[1] + 100)\ngrid = {c: v[2] for c, v in (generate_grid(depth, corner)).items()}\nprint(\"Answer 2:\", dijkstra(grid, corner, target))"
  },
  {
    "day": 23,
    "strategy": "Recursion",
    "part1": "def get_bots(values):\n    r = re.compile(\"pos=<([0-9-]+),([0-9-]+),([0-9-]+)>, r=([0-9]+)\")\n    bots = []\n    for cur in values:\n        if cur.startswith(\"#\"):\n            print(\"# Note: \" + cur)\n        else:\n            m = r.search(cur)\n            if m is None:\n                print(cur)\n            bots.append([int(x) for x in m.groups()])\n    return bots\n\n\ndef calc(values):\n    bots = get_bots(values)\n    best_i = None\n    best_val = None\n    for i in range(len(bots)):\n        if best_i is None or bots[i][3] > best_val:\n            best_val = bots[i][3]\n            best_i = i\n\n    bx, by, bz, bdist = bots[best_i]\n\n    ret = 0\n\n    for i in range(len(bots)):\n        x, y, z, _dist = bots[i]\n\n        if abs(x - bx) + abs(y - by) + abs(z - bz) <= bdist:\n            ret += 1\n\n    return ret\n\n\ndef find(done, bots, xs, ys, zs, dist, ox, oy, oz, forced_count):\n    at_target = []\n\n    for x in range(min(xs), max(xs)+1, dist):\n        for y in range(min(ys), max(ys)+1, dist):\n            for z in range(min(zs), max(zs)+1, dist):\n\n                # See how many bots are possible\n                count = 0\n                for bx, by, bz, bdist in bots:\n                    if dist == 1:\n                        calc = abs(x - bx) + abs(y - by) + abs(z - bz)\n                        if calc <= bdist:\n                            count += 1\n                    else:\n                        calc =  abs((ox+x) - (ox+bx))\n                        calc += abs((oy+y) - (oy+by))\n                        calc += abs((oz+z) - (oz+bz))\n                        # The minus three is to include the current box \n                        # in any bots that are near it\n                        if calc //dist - 3 <= (bdist) // dist:\n                            count += 1\n\n                if count >= forced_count:\n                    at_target.append((x, y, z, count, abs(x) + abs(y) + abs(z)))\n\n    while len(at_target) > 0:\n        best = []\n        best_i = None\n\n        # Find the best candidate from the possible boxes\n        for i in range(len(at_target)):\n            if best_i is None or at_target[i][4] < best[4]:\n                best = at_target[i]\n                best_i = i\n\n        if dist == 1:\n            # At the end, just return the best match\n            return best[4], best[3]\n        else:\n            # Search in the sub boxes, see if we find any matches\n            xs = [best[0], best[0] + dist//2]\n            ys = [best[1], best[1] + dist//2]\n            zs = [best[2], best[2] + dist//2]\n            a, b = find(done, bots, xs, ys, zs, dist // 2, ox, oy, oz, forced_count)\n            if a is None:\n                # This is a false path, remove it from consideration and try any others\n                at_target.pop(best_i)\n            else:\n                # We found something, go ahead and let it bubble up\n                return a, b\n\n    # This means all of the candidates yeild false paths, so let this one\n    # be treated as a false path by our caller\n    return None, None\n\n\ndef calc2(values):\n    bots = get_bots(values)\n\n    # Find the range of the bots\n    xs = [x[0] for x in bots] + [0]\n    ys = [x[1] for x in bots] + [0]\n    zs = [x[2] for x in bots] + [0]\n\n    # Pick a starting resolution big enough to find all of the bots\n    dist = 1\n    while dist < max(xs) - min(xs) or dist < max(ys) - min(ys) or dist < max(zs) - min(zs):\n        dist *= 2\n\n    # And some offset values so there are no strange issues wrapping around zero\n    ox = -min(xs)\n    oy = -min(ys)\n    oz = -min(zs)\n\n    # Try to find all of the bots, backing off with a binary search till\n    # we can find the most bots\n    span = 1\n    while span < len(bots):\n        span *= 2\n    forced_check = 1\n    tried = {}\n\n    best_val, best_count = None, None\n\n    while True:\n        # We might try the same value multiple times, save some time if we've seen it already\n        if forced_check not in tried:\n            tried[forced_check] = find(set(), bots, xs, ys, zs, dist, ox, oy, oz, forced_check)\n        test_val, test_count = tried[forced_check]\n\n        if test_val is None:\n            # Nothing found at this level, so go back\n            if span > 1:\n                span = span // 2\n            forced_check = max(1, forced_check - span)\n        else:\n            # We found something, so go forward\n            if best_count is None or test_count > best_count:\n                best_val, best_count = test_val, test_count\n            if span == 1:\n                # This means we went back one, and it was empty, so we're done!\n                break\n            forced_check += span\n\n    print(\"The max count I found was: \" + str(best_count))\n    return best_val\n\n\ndef run(values):\n    print(\"Nearest the big bot: \" + str(calc(values)))\n    print(\"Best location value: \" + str(calc2(values)))"
  },
  {
    "day": 24,
    "strategy": "GreedyAlgorithm",
    "part1": "class Group:\n    def __init__(self, side, line, boost=0):\n        self.side = side\n\n        attribs, attack = line.split(';')\n        units, hp, *type_mods = attribs.split()\n        units=int(units)\n        hp=int(hp)\n        weak = []\n        immune = []\n        cur = None\n        for w in type_mods:\n            if w == \"weak\":\n                cur = weak\n            elif w == \"immune\":\n                cur = immune\n            else:\n                cur.append(w)\n\n        self.units = units\n        self.hp = hp\n        self.weak = weak\n        self.immune = immune\n        \n        attack_amount, attack_type, initiative = attack.split()\n        attack_amount = int(attack_amount)\n        initiative = int(initiative)\n\n        self.attack = attack_amount + boost\n        self.attack_type = attack_type\n        self.initiative = initiative\n\n        self.attacker = None\n        self.target = None\n\n    def clear(self):\n        self.attacker = None\n        self.target = None\n    \n    def choose(self, groups):\n        assert self.target is None\n        cands = [group for group in groups\n                if group.side != self.side\n                and group.attacker is None\n                and self.damage_prio(group)[0] > 0]\n        if cands:\n            self.target = max(cands, key=lambda group: self.damage_prio(group))\n            assert self.target.attacker is None\n            self.target.attacker = self\n\n    def effective_power(self):\n        return self.units * self.attack\n\n    def target_prio(self):\n        return (-self.effective_power(), -self.initiative)\n\n    def damage_prio(self, target):\n        if target.units == 0:\n            return (0, 0, 0)\n        if self.attack_type in target.immune:\n            return (0, 0, 0)\n        mul = 1\n        if self.attack_type in target.weak:\n            mul = 2\n        return (mul * self.units * self.attack, target.effective_power(), target.initiative)\n\n    def do_attack(self, target):\n        total_attack = self.damage_prio(target)[0]\n        killed = total_attack // target.hp\n        target.units = max(0, target.units - killed)\n\n# immune_system_input = \"\"\"17 5390 weak radiation bludgeoning;4507 fire 2\n# 989 1274 immune fire weak bludgeoning slashing;25 slashing 3\"\"\"\n#\n# infection_input = \"\"\"801 4706 weak radiation;116 bludgeoning 1\n# 4485 2961 immune radiation weak fire cold;12 slashing 4\"\"\"\n\nimmune_system_input = \"\"\"228 8064 weak cold;331 cold 8\n284 5218 immune slashing fire weak radiation;160 radiation 10\n351 4273 immune radiation;93 bludgeoning 2\n2693 9419 immune radiation weak bludgeoning;30 cold 17\n3079 4357 weak radiation cold;13 radiation 1\n906 12842 immune fire;100 fire 6\n3356 9173 immune fire weak bludgeoning;24 radiation 9\n61 9474;1488 bludgeoning 11\n1598 10393 weak fire;61 cold 20\n5022 6659 immune bludgeoning fire cold;12 radiation 15\"\"\"\n\ninfection_input = \"\"\"120 14560 weak radiation bludgeoning immune cold;241 radiation 18\n8023 19573 immune bludgeoning radiation weak cold slashing;4 bludgeoning 4\n3259 24366 weak cold immune slashing radiation bludgeoning;13 slashing 16\n4158 13287;6 fire 12\n255 26550;167 bludgeoning 5\n5559 21287;5 slashing 13\n2868 69207 weak bludgeoning immune fire;33 cold 14\n232 41823 immune bludgeoning;359 bludgeoning 3\n729 41762 weak bludgeoning fire;109 fire 7\n3690 36699;17 slashing 19\"\"\"\n\ndef solve(boost):\n    immune_system_groups = [Group(False, line, boost) for line in immune_system_input.split(\"\\n\")]\n    infection_groups = [Group(True, line) for line in infection_input.split(\"\\n\")]\n\n    groups = immune_system_groups + infection_groups\n\n    old = (-1, -1)\n    while True:\n        groups = sorted(groups, key=lambda group: group.target_prio())\n        for group in groups:\n            group.clear()\n        for group in groups:\n            group.choose(groups)\n        groups = sorted(groups, key=lambda group: -group.initiative)\n        for group in groups:\n            if group.target:\n                group.do_attack(group.target)\n\n        immune_system_units = sum(group.units for group in groups if group.side == False)\n        infection_units = sum(group.units for group in groups if group.side == True)\n        if (immune_system_units, infection_units) == old:\n            return (immune_system_units, infection_units)\n        old = (immune_system_units, infection_units)\n\n# star 1\nprint(solve(0)[1])\n\n# star 2\nfor boost in range(1000000):\n    ans = solve(boost)\n    if ans[1] == 0:\n        print(ans[0])\n        break"
  },
  {
    "day": 25,
    "strategy": "None",
    "part1": "# All of this was written beforehand.\nimport re\ndef ints(s: str):\n    return list(map(int, re.findall(r\"-?\\d+\", s)))  # thanks mserrano!\n\ndef psub(x, y):\n    if len(x) == 2: return [x[0] - y[0], x[1] - y[1]]\n    return [a-b for a, b in zip(x, y)]\n\ndef pdist1(x, y=None):\n    if y is not None: x = psub(x, y)\n    if len(x) == 2: return abs(x[0]) + abs(x[1])\n    return sum(map(abs, x))\n\nclass UnionFind:\n    # n: int\n    # parents: List[Optional[int]]\n    # ranks: List[int]\n    # num_sets: int\n\n    def __init__(self, n: int) -> None:\n        self.n = n\n        self.parents = [None] * n\n        self.ranks = [1] * n\n        self.num_sets = n\n    \n    def find(self, i: int) -> int:\n        p = self.parents[i]\n        if p is None:\n            return i\n        p = self.find(p)\n        self.parents[i] = p\n        return p\n    \n    def in_same_set(self, i: int, j: int) -> bool:\n        return self.find(i) == self.find(j)\n    \n    def merge(self, i: int, j: int) -> None:\n        i = self.find(i)\n        j = self.find(j)\n\n        if i == j:\n            return\n        \n        i_rank = self.ranks[i]\n        j_rank = self.ranks[j]\n\n        if i_rank < j_rank:\n            self.parents[i] = j\n        elif i_rank > j_rank:\n            self.parents[j] = i\n        else:\n            self.parents[j] = i\n            self.ranks[i] += 1\n        self.num_sets -= 1\n\n# Here begins the actual code for today:\ninp = \"\"\"\n0,0,0,0\n3,0,0,0\n0,3,0,0\n0,0,3,0\n0,0,0,3\n0,0,0,6\n9,0,0,0\n12,0,0,0\n\"\"\".strip()\n\nlines = inp.splitlines()\n\nto_i = dict()\n\nuf = UnionFind(len(lines))\n\nfor i, line in enumerate(lines):\n    p = tuple(ints(line))\n    to_i[p] = i\n    \n    for point in to_i:\n        if pdist1(p, point) <= 3:\n            uf.merge(i, to_i[point])\nprint(uf.num_sets)"
  }
]